#!/usr/bin/env bash
set -euo pipefail

if [ -f "$HOME/.config/ai-audio.env" ]; then
  # shellcheck disable=SC1090
  . "$HOME/.config/ai-audio.env"
fi

# Source platform-lib.sh for cross-platform abstractions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
_PLAT_PATHS=("$SCRIPT_DIR/platform-lib.sh" "$HOME/.local/lib/platform-lib.sh")
for _plib in "${_PLAT_PATHS[@]}"; do
  if [ -f "$_plib" ]; then
    # shellcheck source=scripts/platform-lib.sh
    . "$_plib"
    break
  fi
done
unset _plib _PLAT_PATHS

# Dry-run mode: parse and validate input but skip all audio playback
AI_SAY_DRY_RUN="${AI_SAY_DRY_RUN:-0}"

STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/ai-say"
LOCK_FILE="$STATE_DIR/lock"
MAX_CHARS="${AI_TTS_MAX_CHARS:-1600}"
CHUNK_CHARS="${AI_TTS_CHUNK_CHARS:-320}"
VOICE="${AI_TTS_VOICE:-slt}"
GAIN_DB="${AI_TTS_GAIN_DB:-16}"
TEMPO="${AI_TTS_TEMPO:-0.9}"
SINK="${AI_TTS_SINK:-}"
mkdir -p "$STATE_DIR"

KOKORO_PY="${AI_KOKORO_PY:-$HOME/.local/share/kokoro-tts/.venv/bin/python}"
KOKORO_SCRIPT="${AI_KOKORO_SCRIPT:-$HOME/.local/share/kokoro-tts/synthesize.py}"
KOKORO_VOICE="${AI_KOKORO_VOICE:-af_heart}"
KOKORO_LANG="${AI_KOKORO_LANG:-a}"
KOKORO_REPO="${AI_KOKORO_REPO:-hexgrad/Kokoro-82M}"
KOKORO_HF_HOME="${AI_KOKORO_HF_HOME:-$HOME/.local/share/kokoro-tts/hf-cache}"
KOKORO_GAIN_DB="${AI_KOKORO_GAIN_DB:-16}"

if [ "$#" -gt 0 ]; then
  raw_text="$*"
else
  raw_text="$(cat)"
fi

# Strip ANSI/control chars and normalize whitespace.
text="$(printf '%s' "$raw_text" | sed -E 's/\x1B\[[0-9;?]*[ -\/]*[@-~]//g; s/[[:cntrl:]]//g' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//')"
[ -n "$text" ] || exit 0

if [ "${#text}" -gt "$MAX_CHARS" ]; then
  text="${text:0:$MAX_CHARS}"
fi

if [ -z "$SINK" ]; then
  SINK="$(plat_get_default_sink)"
fi

if [ "$AI_SAY_DRY_RUN" = "1" ]; then
  exit 0
fi

if [ -n "$SINK" ]; then
  plat_set_sink "$SINK"
fi

exec 9>"$LOCK_FILE"
flock 9

printf '%s\n' "$text" | fold -s -w "$CHUNK_CHARS" | while IFS= read -r chunk || [ -n "$chunk" ]; do
  [ -n "$chunk" ] || continue

  ok=0

  # 1) Preferred path: Kokoro synthesis to WAV, then boosted playback
  if [ -x "$KOKORO_PY" ] && [ -f "$KOKORO_SCRIPT" ]; then
    wav_tmp="$(mktemp "$STATE_DIR/kokoro.XXXXXX.wav")"
    chunk_tmp="$(mktemp "$STATE_DIR/chunk.XXXXXX.txt")"
    printf '%s' "$chunk" > "$chunk_tmp"
    if HF_HOME="$KOKORO_HF_HOME" CUDA_VISIBLE_DEVICES="" "$KOKORO_PY" "$KOKORO_SCRIPT" \
      --text-file "$chunk_tmp" --out "$wav_tmp" --voice "$KOKORO_VOICE" --lang "$KOKORO_LANG" --repo "$KOKORO_REPO" >/dev/null 2>&1; then
      if command -v ffmpeg >/dev/null 2>&1; then
        boosted_tmp="$(mktemp "$STATE_DIR/boosted.XXXXXX.wav")"
        if ffmpeg -hide_banner -loglevel error -i "$wav_tmp" -af "volume=${KOKORO_GAIN_DB}dB,alimiter=limit=0.98" -f wav "$boosted_tmp" 2>/dev/null; then
          if plat_play_wav "$boosted_tmp" >/dev/null 2>&1; then
            ok=1
          fi
        fi
        rm -f "$boosted_tmp"
      else
        if plat_play_wav "$wav_tmp" >/dev/null 2>&1; then
          ok=1
        fi
      fi
    fi
    rm -f "$wav_tmp" "$chunk_tmp"
  fi

  # 2) Fallback: ffmpeg flite (Linux only â€” flite is a Linux lib)
  if [ "$ok" -ne 1 ]; then
    if command -v ffmpeg >/dev/null 2>&1 && [ "${PLATFORM:-Linux}" = "Linux" ] && command -v paplay >/dev/null 2>&1; then
      txt_tmp="$(mktemp "$STATE_DIR/text.XXXXXX")"
      printf '%s' "$chunk" > "$txt_tmp"
      if ffmpeg -hide_banner -loglevel error -f lavfi -i "flite=textfile=$txt_tmp:voice=$VOICE" -af "volume=${GAIN_DB}dB,atempo=${TEMPO}" -f wav - 2>/dev/null \
          | paplay --volume=65536 --stream-name="ai-say" ${SINK:+--device="$SINK"} >/dev/null 2>&1; then
        ok=1
      fi
      rm -f "$txt_tmp"
    fi
  fi

  # 3) Last fallback: platform TTS
  if [ "$ok" -ne 1 ]; then
    plat_tts_fallback "$chunk"
  fi
done
